"""
OOP is ООП
описание объектов реального мира средствами языка программирования:
свойства и действия (поля и методы)

или: тип данных для определения сложных объектов

класс — прототип будущего объекта, описывающий его свойства и поведение
объект — экземпляр, порождённый классом
атрибут — свойство, присущее объекту
метод — действия, которые объект или класс может выполнить над своими или внешними данными

в Питоне нет примитивных типов! все объектно-обёрточные

функция в классе это метод, её саму по себе не вызовешь
могут быть два идентичных разных (по месту в памяти) объекта

self — контекстный объект, в который передаётся вызванный метод, нужен интерпретатору,
    туда передаётся адрес объекта в памяти, ссылка на объект, вызвавший класс (метод?)
    вместо слова сэлф можно написать любое другое, оно будет просто ссылкой на класс



encapsulation (не должны знать, как работает внутри)
абстракция означает неважность внутренней работы компонентов (ПТК - переключатель теле каналов)


"""

a = 3
print(a.__class__.__name__)


class Fruit:
    pass


a = Fruit()
print(a.__class__)  # класс исполняется в модуле мэйн

a.name = 'яблоко'
a.weight = 150
print(a.name)

b = Fruit()
b.name, b.weight = 'груша', 80
print(b.name)


# print(b.color)


class Greeter:
    def hello(self, name="Noname") -> None:  # первым аргументом сошлётся на себя
        print('здрасьте', name)

    def goodbye(self) -> None:
        print('покеда')


g = Greeter()
g.hello()
g.hello('чувак')


# методы класса и анализ предыдущих вызовов

class Car:
    def __init__(self, brand, model, color):
        self.engine_on = False
        self.brand = brand
        self.model = model
        self.color = color

        print('конструктор выполнен')   # конструктор выделяет объекту память и наделяет свойствами

    def start_engine(self):
        self.engine_on = True  # можно объявить свойство в методе за счёт ссылки на класс!
                               # но тогда он появляется только после запуска этого метода!

    def drive_to(self, target):
        if self.engine_on:
            print(f"едем в {target} на {self.brand} {self.model}")
        else:
            print("не едем")


car = Car("Иж", "Сатурн", "красный")
car.start_engine() #  или car.start_entine = True, но это не по-энкапсуляторски
car.drive_to("город")

# с вызовом конструктора класс() вызывается метод __инит__(сэлф)
# например инициализация свойств

car.drive_to("город")
